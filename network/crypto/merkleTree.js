/**
 * Merkle Tree Implementation for Medical Data Batch Verification
 * Provides efficient batch verification for large medical datasets
 * Enables proof of inclusion without revealing entire dataset
 */

const crypto = require('crypto');
const MedicalHashUtils = require('./hashUtils');

class MedicalMerkleTree {
    constructor(hashAlgorithm = 'sha256') {
        this.hashAlgorithm = hashAlgorithm;
        this.hashUtils = new MedicalHashUtils();
        this.treeLevels = [];
        this.leafNodes = [];
        this.leaves = [];
        this.root = null;
        this.depth = 0;
        this.lastBuilt = null;
    }

    /**
     * Build Merkle tree from medical data array
     * @param {Array} medicalDataArray - Array of medical records or data
     * @param {boolean} preserveOrder - Whether to preserve original data order
     */
    buildTree(medicalDataArray = [], preserveOrder = true) {
        try {
            if (!Array.isArray(medicalDataArray)) {
                medicalDataArray = [];
            }

            if (medicalDataArray.length === 0) {
                this.treeLevels = [[]];
                this.leafNodes = [];
                this.leaves = [];
                this.root = null;
                this.depth = 0;
                this.lastBuilt = new Date().toISOString();
                return {
                    root: null,
                    depth: 0,
                    leafCount: 0,
                    paddedLeafCount: 0,
                    treeBuilt: false,
                    buildTimestamp: this.lastBuilt,
                    leaves: [],
                    treeLevels: [[]],
                    originalData: []
                };
            }

            const orderedData = preserveOrder ? medicalDataArray : [...medicalDataArray].sort();
            this.leafNodes = orderedData.map((data, index) => ({
                index,
                data,
                hash: this.hashUtils.sha256Hash(data)
            }));

            const initialLevel = this.leafNodes.map(node => node.hash);
            this.treeLevels = [initialLevel];
            let currentLevel = initialLevel;

            while (currentLevel.length > 1) {
                currentLevel = this.buildParentLevel(currentLevel);
                this.treeLevels.push(currentLevel);
            }

            this.root = currentLevel[0] || null;
            this.depth = this.treeLevels.length - 1;
            this.leaves = this.leafNodes.map(node => node.hash);
            this.lastBuilt = new Date().toISOString();

            return {
                root: this.root,
                depth: this.depth,
                leafCount: medicalDataArray.length,
                paddedLeafCount: this.treeLevels[0].length,
                treeBuilt: true,
                buildTimestamp: this.lastBuilt,
                leaves: [...this.leaves],
                treeLevels: this.treeLevels.map(level => [...level]),
                originalData: [...orderedData]
            };
        } catch (error) {
            throw new Error(`Merkle tree construction failed: ${error.message}`);
        }
    }

    /**
     * Generate Merkle proof for a specific medical record
     * Proves that a record is included in the tree without revealing other data
     */
    generateProof(treeOrIndex, maybeIndex) {
        try {
            const { context, index } = this.resolveTreeContext(treeOrIndex, maybeIndex);

            if (!context || !context.treeLevels || context.treeLevels.length === 0) {
                return [];
            }

            if (index < 0 || index >= context.treeLevels[0].length) {
                return [];
            }

            const proof = [];
            let currentIndex = index;

            for (let level = 0; level < context.treeLevels.length - 1; level++) {
                const nodes = context.treeLevels[level];
                const isRightNode = currentIndex % 2 === 1;
                const siblingIndex = isRightNode ? currentIndex - 1 : currentIndex + 1;

                if (siblingIndex < nodes.length) {
                    proof.push({
                        position: isRightNode ? 'left' : 'right',
                        hash: nodes[siblingIndex],
                        level
                    });
                }

                currentIndex = Math.floor(currentIndex / 2);
            }

            return proof;
        } catch (error) {
            throw new Error(`Merkle proof generation failed: ${error.message}`);
        }
    }

    /**
     * Verify Merkle proof for a medical record
     * @param {Object} data - Original medical data
     * @param {Object} merkleProof - Proof generated by generateProof
     */
    verifyProof(data, merkleProof, expectedRoot = null) {
        try {
            if (!Array.isArray(merkleProof) || merkleProof.length === 0) {
                return false;
            }

            let currentHash = this.hashUtils.sha256Hash(data);

            for (const element of merkleProof) {
                if (!element || !element.hash) {
                    return false;
                }

                if (element.position === 'left') {
                    currentHash = this.combineHashes(element.hash, currentHash);
                } else {
                    currentHash = this.combineHashes(currentHash, element.hash);
                }
            }

            const rootToCompare = expectedRoot || this.root;
            if (!rootToCompare) {
                return false;
            }

            return currentHash === rootToCompare;
        } catch (error) {
            return false;
        }
    }

    /**
     * Generate batch proof for multiple medical records
     * More efficient than individual proofs when verifying multiple records
     */
    generateBatchProof(dataIndices) {
        try {
            if (!Array.isArray(dataIndices) || dataIndices.length === 0) {
                throw new Error('Invalid data indices array');
            }

            const individualProofs = dataIndices.map(index => ({
                index,
                proof: this.generateProof(index)
            }));

            const optimizedProof = this.optimizeProofs(individualProofs.map(p => ({
                proof: p.proof
            })));

            return {
                batchSize: dataIndices.length,
                dataIndices,
                individualProofs,
                optimizedProof,
                root: this.root,
                generatedAt: new Date().toISOString()
            };
        } catch (error) {
            throw new Error(`Batch proof generation failed: ${error.message}`);
        }
    }

    /**
     * Verify batch proof
     */
    verifyBatchProof(dataArray, batchProof) {
        try {
            if (!Array.isArray(dataArray) || !batchProof || !batchProof.individualProofs) {
                throw new Error('Invalid batch proof data');
            }

            const verificationResults = batchProof.individualProofs.map(item => {
                const record = dataArray[item.index];
                const isValid = this.verifyProof(record, item.proof, batchProof.root);
                return {
                    index: item.index,
                    isValid
                };
            });

            return {
                batchValid: verificationResults.every(r => r.isValid),
                batchSize: verificationResults.length,
                verificationResults,
                validCount: verificationResults.filter(r => r.isValid).length,
                invalidCount: verificationResults.filter(r => !r.isValid).length,
                verifiedAt: new Date().toISOString()
            };
        } catch (error) {
            throw new Error(`Batch proof verification failed: ${error.message}`);
        }
    }

    batchVerify(batchProofs, root = this.root) {
        if (!Array.isArray(batchProofs) || batchProofs.length === 0) {
            return [];
        }

        return batchProofs.map(item => {
            if (!item || !item.record) {
                return false;
            }
            return this.verifyProof(item.record, item.proof, root);
        });
    }

    /**
     * Update tree with new medical data (incremental update)
     * More efficient than rebuilding entire tree
     */
    updateTree(treeOrDataArray, newDataArray = [], appendMode = true) {
        try {
            const baseData = this.extractDataArray(treeOrDataArray);
            const additionalData = Array.isArray(newDataArray) ? newDataArray : [];
            const combined = appendMode ? [...baseData, ...additionalData] : additionalData;
            return this.buildTree(combined);
        } catch (error) {
            throw new Error(`Tree update failed: ${error.message}`);
        }
    }

    /**
     * Get tree statistics and metadata
     */
    getTreeStats() {
        return {
            hasTree: !!this.root,
            root: this.root,
            depth: this.depth,
            leafCount: this.leafNodes.length,
            totalNodes: this.calculateTotalNodes(),
            algorithm: this.hashAlgorithm,
            memoryUsage: this.estimateMemoryUsage(),
            lastBuilt: this.lastBuilt || null
        };
    }

    /**
     * Export tree structure for storage or transmission
     */
    exportTree() {
        try {
            return {
                version: '1.0',
                algorithm: this.hashAlgorithm,
                root: this.root,
                depth: this.depth,
                leaves: this.leafNodes.map(leaf => ({
                    index: leaf.index,
                    hash: leaf.hash
                })),
                tree: this.treeLevels,
                exportedAt: new Date().toISOString(),
                metadata: {
                    leafCount: this.leafNodes.length,
                    totalNodes: this.calculateTotalNodes()
                },
                originalData: this.leafNodes.map(node => node.data)
            };
        } catch (error) {
            throw new Error(`Tree export failed: ${error.message}`);
        }
    }

    /**
     * Import tree structure from exported data
     */
    importTree(exportedTree) {
        try {
            if (exportedTree.version !== '1.0') {
                throw new Error('Unsupported tree version');
            }

            this.hashAlgorithm = exportedTree.algorithm;
            this.root = exportedTree.root;
            this.depth = exportedTree.depth;
            this.treeLevels = exportedTree.tree;
            this.leaves = exportedTree.leaves.map(leaf => leaf.hash);
            this.leafNodes = exportedTree.originalData
                ? exportedTree.originalData.map((data, index) => ({
                    data,
                    hash: exportedTree.leaves[index]?.hash,
                    index
                }))
                : [];
            this.lastBuilt = new Date().toISOString();

            return {
                imported: true,
                leafCount: this.leafNodes.length,
                depth: this.depth,
                root: this.root,
                importedAt: new Date().toISOString()
            };
        } catch (error) {
            throw new Error(`Tree import failed: ${error.message}`);
        }
    }

    /**
     * Generate audit trail for tree operations
     */
    generateAuditTrail(operation, metadata = {}) {
        const auditEntry = {
            operation: operation,
            timestamp: new Date().toISOString(),
            root: this.root,
            leafCount: this.leafNodes.length,
            depth: this.depth,
            metadata: metadata,
            treeHash: this.generateTreeHash()
        };

        return auditEntry;
    }

    // Private helper methods

    /**
     * Combine two hashes to create parent hash
     */
    combineHashes(leftHash, rightHash) {
        const combined = leftHash + rightHash;
        return crypto.createHash(this.hashAlgorithm).update(combined).digest('hex');
    }

    /**
     * Pad array to next power of 2 for balanced tree
     */
    padToNextPowerOfTwo(array) {
        const length = array.length;
        const nextPowerOf2 = Math.pow(2, Math.ceil(Math.log2(length)));

        if (length === nextPowerOf2) {
            return array;
        }

        const padding = nextPowerOf2 - length;
        const paddedArray = [...array];

        // Pad with copies of last element (common practice)
        const lastElement = array[array.length - 1];
        for (let i = 0; i < padding; i++) {
            paddedArray.push({
                ...lastElement,
                index: array.length + i,
                originalIndex: -1 // Mark as padding
            });
        }

        return paddedArray;
    }

    /**
     * Optimize multiple proofs by removing redundant elements
     */
    optimizeProofs(proofs) {
        // This is a simplified optimization
        // In production, implement more sophisticated optimization
        const uniqueElements = new Map();

        proofs.forEach(proofContainer => {
            const proofArray = Array.isArray(proofContainer.proof)
                ? proofContainer.proof
                : Array.isArray(proofContainer)
                    ? proofContainer
                    : [];
            proofArray.forEach(element => {
                const key = `${element.level}-${element.hash}`;
                if (!uniqueElements.has(key)) {
                    uniqueElements.set(key, element);
                }
            });
        });

        return {
            optimizedElements: Array.from(uniqueElements.values()),
            originalElementCount: proofs.reduce((sum, proof) => {
                const proofArray = Array.isArray(proof.proof) ? proof.proof : [];
                return sum + proofArray.length;
            }, 0),
            optimizedElementCount: uniqueElements.size,
            spaceSavings: uniqueElements.size === 0 ? 0 :
                1 - (uniqueElements.size / Math.max(1, proofs.reduce((sum, proof) => {
                    const proofArray = Array.isArray(proof.proof) ? proof.proof : [];
                    return sum + proofArray.length;
                }, 0)))
        };
    }

    /**
     * Calculate total number of nodes in tree
     */
    calculateTotalNodes() {
        return this.treeLevels.reduce((sum, level) => sum + level.length, 0);
    }

    /**
     * Estimate memory usage of tree
     */
    estimateMemoryUsage() {
        const hashSize = 64; // SHA-256 hex string length
        const totalHashes = this.calculateTotalNodes();
        const leafDataSize = this.leafNodes.length * 200; // Rough estimate

        return {
            hashStorage: totalHashes * hashSize,
            leafStorage: leafDataSize,
            totalBytes: (totalHashes * hashSize) + leafDataSize,
            totalMB: ((totalHashes * hashSize) + leafDataSize) / (1024 * 1024)
        };
    }

    /**
     * Generate hash of entire tree structure
     */
    generateTreeHash() {
        if (!this.root) return null;

        const treeStructure = {
            root: this.root,
            depth: this.depth,
            leafCount: this.leafNodes.length,
            algorithm: this.hashAlgorithm
        };

        return crypto.createHash('sha256')
            .update(JSON.stringify(treeStructure))
            .digest('hex');
    }

    buildParentLevel(level) {
        const nextLevel = [];
        for (let i = 0; i < level.length; i += 2) {
            const left = level[i];
            const right = i + 1 < level.length ? level[i + 1] : level[i];
            nextLevel.push(this.combineHashes(left, right));
        }
        return nextLevel;
    }

    resolveTreeContext(treeOrIndex, maybeIndex) {
        if (treeOrIndex && typeof treeOrIndex === 'object' && Array.isArray(treeOrIndex.treeLevels)) {
            return {
                context: treeOrIndex,
                index: typeof maybeIndex === 'number' ? maybeIndex : 0
            };
        }

        return {
            context: {
                treeLevels: this.treeLevels,
                root: this.root,
                leaves: this.leaves
            },
            index: typeof treeOrIndex === 'number' ? treeOrIndex : 0
        };
    }

    extractDataArray(treeOrData) {
        if (Array.isArray(treeOrData)) {
            return [...treeOrData];
        }

        if (treeOrData && Array.isArray(treeOrData.originalData)) {
            return [...treeOrData.originalData];
        }

        return this.leafNodes.map(node => node.data);
    }
}

module.exports = MedicalMerkleTree;